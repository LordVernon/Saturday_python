import random

def Task_6_16():
    '''Дано натуральное число A. Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число n, 
                        что φn = A. Если А не является числом Фибоначчи, выведите число -1.'''

    A = int(input())
    f_prev, f_next = 0, 1
    n = 1
    while f_next <= A:
        if f_next == A:
            print(n)
            break
        f_prev, f_next = f_next, f_next + f_prev
        n += 1
    else:
        print(-1)

def Task_7_3():
    #Дан список чисел. Выведите все элементы списка, которые больше предыдущего элемента.

    A = [random.randint(0, 100) for i in range(random.randint(5, 20))]
    B = []
    for i in range(1, len(A)):
        if A[i - 1] < A[i]:
            B.append(A[i])
    print(A)
    print(B)

def Task_8_3(string):
    '''Напишите функцию capitalize(), которая принимает слово из маленьких латинских букв и возвращает его же, 
            меняя первую букву на большую.Например, print(capitalize('word')) должно печатать слово Word.
       На вход подаётся строка, состоящая из слов, разделённых одним пробелом. Слова состоят из маленьких латинских букв. 
                Напечатайте исходную строку, сделав так, чтобы каждое слово начиналось с большой буквы. 
                                  При этом используйте вашу функцию capitalize().'''

    b = string.title()
    print(b)

def Task_9_1():
    '''     Найдите индексы первого вхождения максимального элемента. Выведите два числа: номер строки и номер столбца,
     в которых стоит наибольший элемент в двумерном массиве. Если таких элементов несколько, то выводится тот, у которого меньше 
                   номер строки, а если номера строк равны то тот, у которого меньше номер столбца.'''
    
    n = int(input())
    m = int(input())
    A = [[random.randint(0, 100) for i in range(m)] for j in range(n)]
    print(A)
    r = 0
    ind_n = 0
    for i in A:
        if r < max(i):
            r = max(i)
            best_n, best_m = ind_n, i.index(r)
        ind_n += 1
    print(f"Максимальное значение {r}, индексы которого {best_n} {best_m}")

def Task_10_9():
    '''      Каждый из некоторого множества школьников некоторой школы знает некоторое количество языков. 
       Нужно определить сколько языков знают все школьники, и сколько языков знает хотя бы один из школьников.

    В первой строке задано количество школьников. Для каждого из школьников сперва записано количество языков, которое он знает,
                               а затем - названия языков, по одному в строке.

    В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки - список таких языков.
          Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список таких языков.
                       Языки нужно выводить в лексикографическом порядке, по одному на строке.'''
    
    n = int(input())
    print("Вводим языки:")
    Students = [{input() for j in range(int(input()))} for i in range(n)]
    well_known = set.intersection(*Students)
    all_known = set.union(*Students)
    print(f"Языков, которые знают все {len(well_known)}: {sorted(well_known)}")
    print(f"Языков в общем {len(all_known)}: {sorted(all_known)}")



def Task_11_12():
    '''Даны два элемента в дереве. Определите, является ли один из них потомком другого.

       Во входных данных записано дерево в том же формате, что и в предыдущей задаче Далее идет число запросов K.
                     В каждой из следующих K строк, содержатся имена двух элементов дерева.

       Для каждого такого запроса выведите одно из трех чисел: 1, если первый элемент является предком второго, 2, 
               если второй является предком первого или 0, если ни один из них не является предком другого.'''
    
    def isancestor(man_1, man_2):
        if man_1 == man_2:
            return True
        while man_1 in tree:
            man_1 = tree[man_1]
            if man_1 == man_2:
                return True
        return False
    
    
    tree = dict()
    n = int(input())
    for i in range(n - 1):
        child, parent = input().split()
        tree[child] = parent
    k = int(input())
    for j in range(k):
        man_1, man_2 = input().split()
        if isancestor(man_1, man_2):
            print(2, end=' ')
        elif isancestor(man_2, man_1):
            print(1, end=' ')
        else:
            print(0, ' ')

Task_6_16()
Task_7_3()
Task_8_3(input())
Task_9_1()
Task_10_9()
Task_11_12()
